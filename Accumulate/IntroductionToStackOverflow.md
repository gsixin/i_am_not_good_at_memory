## Introduction to Stack Overflow

下午临近下班就两个问题请教了一个同事，同事还是有一定水平的啊。还是很明白的讲清楚了Stack Overflow是怎么一回事情，虽然已经认识清楚，但是还是初步深度不够，特此记录吧。

请教人家的两个问题是这样的：
* [这个页面](https://www.cnblogs.com/wolf-sun/p/4209521.html)里边有一句话觉得不是很理解`在多线程中，每个线程都有自己的资源，但是代码区是共享的，即每个线程都可以执行相同的函数。这可能带来的问题就是几个线程同时执行一个函数，导致数据的混乱，产生不可预料的结果，因此我们必须避免这种情况的发生。`,既然每个线程的线程执行栈是独立的，那么调用共享的代码应该是不会有什么问题的，它所说的`数据混乱`应该是在一个函数操作了堆内存中的变量，或者说此函数作用域外变量导致了所谓的线程安全问题（也就是数据不一致问题）。这也就是现在为什么要有`锁`这么个东西了。--这个问题在对话中也就引出了线程安全这个比较重要的概念，涉及到堆内存数据问题，下边在对话中自己又想到C++中对象指针释放，内存溢出等问题--
* 关于C++中指针的一些基本问题，比如数组名即为数组的指针，可以直接`cout`打印的，但是对象名就不能直接打印，这个很确定。需要进一步继续研究，搞数量这个指针的操作。

重点来了：
### 什么是Stack Overflow
Stack Overflow的直接原因就是，分配给程序的内存不够用了，就报错了（既然是Overflow，是因为检测到引用了规定内存地址外的地方而导致的报错吗？存疑）。

一个程序初始阶段分配了固定的内存大小（物理地址也固定了吗？），然后就分为`堆内存`和`栈内存`两部分分别使用。
当进入方法内部的时候，使用的是栈内存（栈内存的大小有限，具体多少不清楚，等再查查），所以一个方法中可供栈内存的操作空间有限，因此一些





```flow
op1=>operation: Heap region
op2=>operation: Boundary
op3=>operation: Stack region

op1->op2->op3

```